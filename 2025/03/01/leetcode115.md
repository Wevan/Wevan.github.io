# 一个例子让你看懂leetcode 115！

|  | “” | r | a | b | b | i | t |
| --- | --- | --- | --- | --- | --- | --- | --- |
| “” | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| r | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| a | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| b | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| b | 1 | 1 | 1 | 2 | 1 | 0 | 0 |
| b | 1 | 1 | 1 | 3 | 3 | 0 | 0 |
| i | 1 | 1 | 1 | 3 | 3 | 3 | 0 |
| t | 1 | 1 | 1 | 3 | 3 | 3 | 3 |

上表中的列为s串，行为t串，我们要找的就是t在s中的不同匹配子序列个数。

首先，我们明白dp[i][j]指的是[0,i-1]的s串中有多少个子序列能够匹配[0,j-1]的t串的。匹配意思是：比如s串目前为rabbb，t串为rab，那么就是3个匹配。

同时dp[i][j]有意义的值是i,j都从1开始，当i,j都是0时候，我们可以认为s和t串均为空串，空串是任何字串的子序列，也是空串自身的子序列，所以我们可以将dp数组的dp[0][0]初始化为1，dp第一列也初始化为1，因为空串是任何字串的字串。而dp第一行除了dp[0][0]之外，t串只要有字符以后，都不可能是空串的匹配，所以都初始化为0。

接下来我们就可以填写表格了，我们先不着急想出递推公式。先靠题意填写dp表格的数值。比如，当s串目前遍历到i=1，即s[i-1]=s[0]=’r‘时候，此时这行的t串按顺序遍历rabbit各个字符，比如当遍历到t串的r时候，t的r是s的r的子序列，所以这个值为1，以此类推完成整个表格的值填写。

然后我们开始找规律，挑选大的值比较好理解。

比如我们s串已经遍历到了rabbb的最后一个b，此时t串遍历到了rabb。

此时s[i-1]=t[j-1]=’b’。我们想得出这个格子的数值，我们直接思考当前t串匹配s的子序列有多少。

此时很直观的一种情况是，我们t串当前已经是rabb，可以和s串的**rab**b**b** 匹配，这个选择是我们让t串的最后一个字符也就是t[j-1]和s串的最后一个字符做匹配（注意此时我们求解的是dp[i][j]的值）。那么我们需要知道除去当前的s[i-1]和t[j-1]，s和t在s[i-2]和t[j-2]时候已经有多少种匹配方式了。偏一下题，我们假设改一下这个字符串，比如s和t此时的前边（即到s[i-2]和t[j-2]时）也可能是**ra**rabb和rab（前边的ra是假设修改了例子的字符串，作为一个新的例子来考虑），那么当他们再往后一个都是b，分别为rarabb**b**和rab**b**时，我们要考虑使用最后一个b作为一个匹配结果考虑时候，我们就需要知道rarab和rrab时候的匹配的子序列是多少个了。因为我们使用最后一个b作为当前批次的匹配结尾，前边ra依旧会有很多结果，比如：**ra**rabb**b**和**ra**b**b**，ra**ra**bb**b**和**ra**b**b**。即不同的ra和当前b的组合结果，才是选择当前b作为此次匹配情况的真正结果数。那么这个数值就是等于不同的ra组合，也就是这个结果并不会受当前b的影响，为dp[i-1][j-1]时候的数值。这就是情况1。

再来看情况2，我们不使用当前s串的这个b作为匹配值，【这里方便看我再把当前遍历的情况写一遍：我们s串已经遍历到了rabbb的最后一个b，此时t串遍历到了rabb】

情况2即匹配为，即**rabb**b和rabb，就是不用s串当前遍历到的最后一个b作为与t串最后一个字符b匹配项。那么这个结果很显然就是s串的上一个字符的结果，即dp[i-1][j]，这个从上边的dp表上也可以看出。

所以s[i-1]=t[j-1]的情况，递推公式即为dp[i][j]=dp[i-1][j-1]+dp[i-1][j]。

当s[i-1]!=t[j-1]时，我们只需要保持之前已经匹配上的值就可以了，比如s为rabb，t为ra，此时只需要知道rab和ra有多少匹配的子序列就行了，而rab和ra的匹配序列只要知道ra和ra的匹配子序列有多少就行。递推公式即为dp[i][j]=dp[i-1][j]。